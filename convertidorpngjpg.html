<!doctype html>
<html lang="es-AR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Matt's Tools — Convertidor JPG ⇄ PNG</title>
  <style>
    :root{
      --bg:#0b0f10;
      --card:#121819;
      --text:#e8f1ef;
      --muted:#9bb2ad;
      --accent:#35ff7a;
      --accent2:#1ed760;
      --border:rgba(255,255,255,.10);
      --shadow: 0 12px 28px rgba(0,0,0,.45);
      --radius:16px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Noto Sans", "Liberation Sans", sans-serif;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0; min-height:100vh;
      font-family:var(--sans);
      background:
        radial-gradient(1100px 600px at 20% 0%, rgba(53,255,122,.10), transparent 60%),
        radial-gradient(900px 600px at 80% 20%, rgba(53,255,122,.06), transparent 60%),
        var(--bg);
      color:var(--text);
      display:flex; align-items:center; justify-content:center;
      padding:24px;
    }
    .card{
      width:min(1100px, 100%);
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    header{
      padding:18px 22px;
      border-bottom:1px solid var(--border);
      display:flex;
      gap:14px;
      align-items:flex-start;
      justify-content:space-between;
    }
    h1{
      margin:0;
      font-size:18px;
      letter-spacing:.2px;
    }
    .sub{
      margin:6px 0 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
      max-width: 60ch;
    }
    .badge{
      font-family:var(--mono);
      font-size:11px;
      color:rgba(53,255,122,.95);
      border:1px solid rgba(53,255,122,.35);
      background:rgba(53,255,122,.06);
      padding:6px 10px;
      border-radius:999px;
      white-space:nowrap;
      align-self:flex-start;
    }

    .grid{
      display:grid;
      grid-template-columns: 1.05fr .95fr;
      gap:16px;
      padding:16px 22px 22px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }

    .panel{
      background:rgba(0,0,0,.22);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
    }

    .drop{
      border:1px dashed rgba(255,255,255,.22);
      background:rgba(0,0,0,.18);
      border-radius:14px;
      padding:14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      transition: border-color .15s ease, background .15s ease;
    }
    .drop.dragover{
      border-color: rgba(53,255,122,.75);
      background: rgba(53,255,122,.06);
    }
    .drop .left{
      display:flex; flex-direction:column; gap:6px;
      min-width: 0;
    }
    .drop .title{
      font-family:var(--mono);
      font-size:12px;
      color:#cfe3de;
      opacity:.95;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .drop .hint{
      font-size:12px;
      color:var(--muted);
      line-height:1.35;
    }
    input[type="file"]{ display:none; }

    .btn{
      appearance:none;
      border:1px solid rgba(53,255,122,.35);
      background:rgba(53,255,122,.08);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      transition: transform .05s ease, background .15s ease, opacity .15s ease;
      display:inline-flex;
      align-items:center;
      gap:10px;
      user-select:none;
      font-family:var(--sans);
    }
    .btn:hover{ background:rgba(53,255,122,.12); }
    .btn:active{ transform: translateY(1px); }
    .btn:disabled{ opacity:.45; cursor:not-allowed; }
    .btn.secondary{
      border-color: rgba(255,255,255,.14);
      background: rgba(255,255,255,.04);
    }
    .btn.secondary:hover{ background: rgba(255,255,255,.06); }

    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:flex-end;
      margin-top:12px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      min-width: 170px;
      flex: 1 1 170px;
    }
    .label{
      font-size:11px;
      color:var(--muted);
      font-family:var(--mono);
      letter-spacing:.2px;
    }
    .select, .input{
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.18);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      font-family:var(--mono);
      font-size:12px;
      outline:none;
    }
    .input:disabled{
      opacity:.5;
      cursor:not-allowed;
    }

    .twocol{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .twocol{ grid-template-columns: 1fr; }
    }

    .preview{
      width:100%;
      aspect-ratio: 16/10;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:
        repeating-conic-gradient(from 0deg, rgba(255,255,255,.06) 0 25%, rgba(255,255,255,.02) 0 50%) 0 0 / 20px 20px,
        rgba(0,0,0,.25);
      display:flex;
      align-items:center;
      justify-content:center;
      overflow:hidden;
      position:relative;
    }
    .preview img{
      max-width:100%;
      max-height:100%;
      object-fit:contain;
      display:block;
    }
    .small{
      font-size:12px;
      color:var(--muted);
      line-height:1.45;
    }

    .list{
      margin-top:12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.24);
      overflow:hidden;
    }
    .listHeader{
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      font-family:var(--mono);
      font-size:12px;
      color:#cfe3de;
    }
    .items{
      max-height: 260px;
      overflow:auto;
    }
    .item{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      align-items:center;
    }
    .item:last-child{ border-bottom:none; }
    .name{
      color:#cfe3de;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .meta{
      text-align:right;
      white-space:nowrap;
    }

    .log{
      margin-top:12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.24);
      padding:12px;
      font-family:var(--mono);
      font-size:12px;
      color:var(--muted);
      min-height:54px;
      white-space:pre-wrap;
    }

    .warn{ color:#ffd38a; }
    .ok{ color: rgba(53,255,122,.95); }

    .hr{
      height:1px;
      background:rgba(255,255,255,.10);
      margin:12px 0;
    }

    .inline{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .pill{
      font-family:var(--mono);
      font-size:11px;
      color:rgba(53,255,122,.95);
      border:1px solid rgba(53,255,122,.25);
      background:rgba(53,255,122,.05);
      padding:5px 10px;
      border-radius:999px;
      white-space:nowrap;
    }
  </style>
</head>
<body>
  <div class="card">
    <header>
      <div>
        <h1>Matt’s Tools — Convertidor JPG ⇄ PNG</h1>
        <p class="sub">Arrastrá y soltá imágenes (JPG/PNG), convertí por lote, ajustá fondo, resize y compresión. Todo offline, en tu navegador.</p>
      </div>
      <div class="badge">offline • batch • drag&drop</div>
    </header>

    <div class="grid">
      <!-- IZQUIERDA: controles -->
      <div class="panel">
        <div id="drop" class="drop" tabindex="0" role="button" aria-label="Zona para arrastrar y soltar">
          <div class="left">
            <div class="title" id="dropTitle">Arrastrá JPG/PNG acá o elegí archivos</div>
            <div class="hint">Tip: podés soltar varios. Se van a listar abajo.</div>
          </div>
          <div class="inline">
            <button class="btn" id="pickBtn">Elegir archivos</button>
            <button class="btn secondary" id="clearBtn" disabled>Limpiar</button>
          </div>
          <input id="file" type="file" accept="image/jpeg,image/png" multiple />
        </div>

        <div class="row">
          <div class="field">
            <div class="label">Formato destino</div>
            <select id="target" class="select">
              <option value="image/png">PNG</option>
              <option value="image/jpeg">JPG</option>
            </select>
          </div>

          <div class="field" id="jpgQualityField">
            <div class="label">Calidad JPG</div>
            <select id="jpgQuality" class="select">
              <option value="0.95">95%</option>
              <option value="0.92" selected>92%</option>
              <option value="0.85">85%</option>
              <option value="0.75">75%</option>
              <option value="0.60">60%</option>
            </select>
          </div>

          <div class="field" id="pngCompressField">
            <div class="label">PNG (canvas)</div>
            <select id="pngHint" class="select" title="PNG no tiene 'calidad' estándar; esto es un hint simple">
              <option value="off" selected>Sin cambio</option>
              <option value="on">Re-encode (a veces baja peso)</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="field">
            <div class="label">Fondo al convertir a JPG</div>
            <select id="bgMode" class="select">
              <option value="white" selected>Blanco</option>
              <option value="black">Negro</option>
              <option value="transparent">Transparente (solo si destino = PNG)</option>
              <option value="color">Color personalizado</option>
            </select>
          </div>

          <div class="field" id="bgColorField" style="display:none;">
            <div class="label">Color</div>
            <input id="bgColor" class="input" type="text" value="#ffffff" placeholder="#rrggbb" />
          </div>
        </div>

        <div class="hr"></div>

        <div class="row">
          <div class="field">
            <div class="label">Resize</div>
            <select id="resizeMode" class="select">
              <option value="none" selected>Sin resize</option>
              <option value="width">Fijar ancho</option>
              <option value="height">Fijar alto</option>
              <option value="fit">Encajar (max W/H)</option>
              <option value="cover">Cubrir (min W/H, recorta)</option>
            </select>
          </div>

          <div class="field">
            <div class="label">Ancho (px)</div>
            <input id="w" class="input" type="number" min="1" step="1" placeholder="ej: 1920" disabled />
          </div>

          <div class="field">
            <div class="label">Alto (px)</div>
            <input id="h" class="input" type="number" min="1" step="1" placeholder="ej: 1080" disabled />
          </div>
        </div>

        <div class="row">
          <div class="field" style="min-width:260px;">
            <div class="label">Nombre de descarga (solo 1 archivo)</div>
            <input id="singleName" class="input" type="text" placeholder="ej: portada_convertida" disabled />
          </div>

          <div class="inline" style="margin-left:auto;">
            <button id="convertBtn" class="btn" disabled>Convertir y descargar</button>
          </div>
        </div>

        <div class="log" id="log">Soltá archivos para empezar.</div>

        <p class="small warn" id="alphaNote" style="display:none; margin-top:10px;">
          Ojo: hay PNGs con transparencia. Si convertís a JPG, la transparencia se rellena con el fondo elegido.
        </p>
      </div>

      <!-- DERECHA: preview + lista -->
      <div class="panel">
        <div class="small">Vista previa (primer archivo)</div>
        <div class="preview" id="preview">
          <span class="small">Sin imagen</span>
        </div>

        <div class="list" style="margin-top:12px;">
          <div class="listHeader">
            <span>Archivos cargados</span>
            <span class="pill" id="countPill">0</span>
          </div>
          <div class="items" id="items"></div>
        </div>

        <div class="small" style="margin-top:10px;">
          Nota: por lote, el navegador descarga uno por uno (sin ZIP). Si querés ZIP offline, te lo armo con JSZip embebido.
        </div>
      </div>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    const drop = $("drop");
    const fileInput = $("file");
    const pickBtn = $("pickBtn");
    const clearBtn = $("clearBtn");
    const targetSel = $("target");
    const jpgQualityField = $("jpgQualityField");
    const jpgQualitySel = $("jpgQuality");
    const pngCompressField = $("pngCompressField");
    const pngHintSel = $("pngHint");

    const bgModeSel = $("bgMode");
    const bgColorField = $("bgColorField");
    const bgColorInput = $("bgColor");

    const resizeModeSel = $("resizeMode");
    const wInput = $("w");
    const hInput = $("h");

    const singleNameInput = $("singleName");
    const convertBtn = $("convertBtn");

    const preview = $("preview");
    const itemsEl = $("items");
    const countPill = $("countPill");
    const log = $("log");
    const alphaNote = $("alphaNote");

    /** @type {Array<{file: File, url: string, img?: HTMLImageElement, width?: number, height?: number, hasAlpha?: boolean}>} */
    let files = [];

    function setLog(msg){ log.textContent = msg; }

    function formatBytes(bytes){
      const units = ["B","KB","MB","GB"];
      let i = 0, v = bytes;
      while (v >= 1024 && i < units.length-1){ v /= 1024; i++; }
      return `${v.toFixed(i===0?0:1)} ${units[i]}`;
    }

    function getBaseName(filename){
      const dot = filename.lastIndexOf(".");
      return dot >= 0 ? filename.slice(0, dot) : filename;
    }

    function extFor(mime){
      return mime === "image/png" ? "png" : "jpg";
    }

    function clearPreview(){
      preview.innerHTML = `<span class="small">Sin imagen</span>`;
    }

    function showPreview(url){
      preview.innerHTML = "";
      const img = new Image();
      img.src = url;
      img.alt = "Vista previa";
      preview.appendChild(img);
    }

    function renderList(){
      itemsEl.innerHTML = "";
      countPill.textContent = String(files.length);

      if (files.length === 0){
        itemsEl.innerHTML = `<div class="item"><div class="name">—</div><div class="meta">—</div></div>`;
        clearPreview();
        alphaNote.style.display = "none";
        convertBtn.disabled = true;
        clearBtn.disabled = true;
        singleNameInput.disabled = true;
        singleNameInput.value = "";
        return;
      }

      for (const f of files){
        const row = document.createElement("div");
        row.className = "item";
        const left = document.createElement("div");
        left.className = "name";
        left.textContent = f.file.name;
        const right = document.createElement("div");
        right.className = "meta";
        const dim = (f.width && f.height) ? `${f.width}×${f.height}` : "…";
        right.textContent = `${formatBytes(f.file.size)} • ${dim}`;
        row.appendChild(left);
        row.appendChild(right);
        itemsEl.appendChild(row);
      }

      clearBtn.disabled = false;
      convertBtn.disabled = false;

      // nombre editable solo si uno
      if (files.length === 1){
        singleNameInput.disabled = false;
        const base = getBaseName(files[0].file.name);
        singleNameInput.value = base + "_convertido";
      } else {
        singleNameInput.disabled = true;
        singleNameInput.value = "";
      }

      showPreview(files[0].url);

      // alpha note
      const anyAlpha = files.some(x => x.hasAlpha);
      alphaNote.style.display = anyAlpha ? "block" : "none";
    }

    function updateUI(){
      const target = targetSel.value;
      jpgQualityField.style.display = (target === "image/jpeg") ? "flex" : "none";
      pngCompressField.style.display = (target === "image/png") ? "flex" : "none";

      // bgMode "transparent" solo tiene sentido si destino es PNG
      const optTransparent = [...bgModeSel.options].find(o => o.value === "transparent");
      if (optTransparent){
        optTransparent.disabled = (target !== "image/png");
        if (target !== "image/png" && bgModeSel.value === "transparent"){
          bgModeSel.value = "white";
        }
      }

      bgColorField.style.display = (bgModeSel.value === "color") ? "block" : "none";

      const rm = resizeModeSel.value;
      const enableW = (rm === "width" || rm === "fit" || rm === "cover");
      const enableH = (rm === "height" || rm === "fit" || rm === "cover");
      wInput.disabled = !enableW;
      hInput.disabled = !enableH;

      // placeholder hints
      if (rm === "width"){ wInput.placeholder = "ej: 1024"; hInput.placeholder = "auto"; }
      if (rm === "height"){ hInput.placeholder = "ej: 1024"; wInput.placeholder = "auto"; }
      if (rm === "fit" || rm === "cover"){ wInput.placeholder = "max W"; hInput.placeholder = "max H"; }
      if (rm === "none"){ wInput.placeholder = "—"; hInput.placeholder = "—"; }
    }

    function detectAlpha(canvas){
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      const { width, height } = canvas;
      const data = ctx.getImageData(0, 0, width, height).data;
      const step = Math.max(1, Math.floor((width * height) / 200000)); // muestreo
      for (let i = 3; i < data.length; i += 4 * step){
        if (data[i] !== 255) return true;
      }
      return false;
    }

    async function loadOneFile(file){
      if (!file) return null;
      if (!["image/jpeg","image/png"].includes(file.type)) return null;

      const url = URL.createObjectURL(file);
      const img = new Image();
      img.decoding = "async";
      img.src = url;

      await new Promise((res, rej) => {
        img.onload = () => res();
        img.onerror = () => rej(new Error("No se pudo leer una imagen."));
      });

      // detectar alpha si PNG
      let hasAlpha = false;
      if (file.type === "image/png"){
        const c = document.createElement("canvas");
        c.width = img.naturalWidth;
        c.height = img.naturalHeight;
        const ctx = c.getContext("2d");
        ctx.drawImage(img, 0, 0);
        hasAlpha = detectAlpha(c);
      }

      return {
        file,
        url,
        img,
        width: img.naturalWidth,
        height: img.naturalHeight,
        hasAlpha
      };
    }

    async function addFiles(fileList){
      const incoming = [...fileList].filter(f => ["image/jpeg","image/png"].includes(f.type));
      if (incoming.length === 0){
        setLog("No vi JPG/PNG válidos en lo que soltaste.");
        return;
      }

      setLog(`Cargando ${incoming.length} archivo(s)…`);
      const loaded = [];
      for (const f of incoming){
        try{
          const item = await loadOneFile(f);
          if (item) loaded.push(item);
        }catch(e){
          // ignorar uno roto
        }
      }

      if (loaded.length === 0){
        setLog("No pude cargar ningún archivo. ¿Están corruptos o son de otro formato?");
        return;
      }

      // liberar URLs anteriores si limpiamos?
      // Acá simplemente sumamos a la lista:
      files = files.concat(loaded);

      setLog(`Listo: ${files.length} archivo(s) en cola. Elegí ajustes y convertí.`);
      renderList();
    }

    function clearAll(){
      for (const f of files){
        try{ URL.revokeObjectURL(f.url); }catch{}
      }
      files = [];
      setLog("Limpio. Soltá archivos para empezar.");
      renderList();
    }

    function parseBg(){
      const mode = bgModeSel.value;
      if (mode === "white") return "#ffffff";
      if (mode === "black") return "#000000";
      if (mode === "transparent") return null; // solo válido para PNG
      if (mode === "color"){
        const v = (bgColorInput.value || "").trim();
        // aceptación simple: #rgb o #rrggbb
        if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)) return v;
        // fallback
        return "#ffffff";
      }
      return "#ffffff";
    }

    function computeResize(srcW, srcH){
      const mode = resizeModeSel.value;
      const W = parseInt(wInput.value, 10);
      const H = parseInt(hInput.value, 10);

      if (mode === "none"){
        return { outW: srcW, outH: srcH, sx:0, sy:0, sWidth:srcW, sHeight:srcH, dx:0, dy:0, dWidth:srcW, dHeight:srcH };
      }

      if (mode === "width" && Number.isFinite(W) && W > 0){
        const outW = W;
        const outH = Math.round(srcH * (W / srcW));
        return { outW, outH, sx:0, sy:0, sWidth:srcW, sHeight:srcH, dx:0, dy:0, dWidth:outW, dHeight:outH };
      }

      if (mode === "height" && Number.isFinite(H) && H > 0){
        const outH = H;
        const outW = Math.round(srcW * (H / srcH));
        return { outW, outH, sx:0, sy:0, sWidth:srcW, sHeight:srcH, dx:0, dy:0, dWidth:outW, dHeight:outH };
      }

      if ((mode === "fit" || mode === "cover") && Number.isFinite(W) && W > 0 && Number.isFinite(H) && H > 0){
        const scaleFit = Math.min(W/srcW, H/srcH);
        const scaleCover = Math.max(W/srcW, H/srcH);
        const scale = (mode === "fit") ? scaleFit : scaleCover;

        const scaledW = srcW * scale;
        const scaledH = srcH * scale;

        const outW = Math.round(W);
        const outH = Math.round(H);

        // para fit: no recortamos, centramos (letterbox) dentro del canvas
        if (mode === "fit"){
          const dx = Math.round((outW - scaledW)/2);
          const dy = Math.round((outH - scaledH)/2);
          return {
            outW, outH,
            sx:0, sy:0, sWidth:srcW, sHeight:srcH,
            dx, dy,
            dWidth: Math.round(scaledW),
            dHeight: Math.round(scaledH)
          };
        }

        // para cover: recortamos fuente para llenar exactamente
        // calculamos el rectángulo fuente que corresponde al canvas final
        const srcCropW = outW / scale;
        const srcCropH = outH / scale;
        const sx = (srcW - srcCropW) / 2;
        const sy = (srcH - srcCropH) / 2;

        return {
          outW, outH,
          sx, sy,
          sWidth: srcCropW,
          sHeight: srcCropH,
          dx:0, dy:0,
          dWidth: outW,
          dHeight: outH
        };
      }

      // si faltan datos, fallback sin resize
      return { outW: srcW, outH: srcH, sx:0, sy:0, sWidth:srcW, sHeight:srcH, dx:0, dy:0, dWidth:srcW, dHeight:srcH };
    }

    function downloadBlob(blob, filename){
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 1500);
    }

    async function convertOne(entry, index, total){
      const target = targetSel.value; // image/png o image/jpeg
      const q = parseFloat(jpgQualitySel.value);
      const bg = parseBg();
      const pngHint = pngHintSel.value;

      const img = entry.img;
      const srcW = entry.width;
      const srcH = entry.height;

      const r = computeResize(srcW, srcH);

      const canvas = document.createElement("canvas");
      canvas.width = r.outW;
      canvas.height = r.outH;
      const ctx = canvas.getContext("2d");

      // fondo
      if (target === "image/jpeg"){
        // jpg siempre necesita un fondo
        ctx.fillStyle = (bg === null) ? "#ffffff" : bg;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      } else {
        // destino PNG
        if (bg !== null){
          // si no es transparente, pintamos fondo (sirve para "fit" con bordes)
          ctx.fillStyle = bg;
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        } // si bg null => transparente
      }

      // dibujar
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(
        img,
        r.sx, r.sy, r.sWidth, r.sHeight,
        r.dx, r.dy, r.dWidth, r.dHeight
      );

      const base = getBaseName(entry.file.name);
      const ext = extFor(target);

      let outName;
      if (total === 1 && singleNameInput.value.trim()){
        outName = `${singleNameInput.value.trim()}.${ext}`;
      } else {
        outName = `${base}.${ext}`;
      }

      const blob = await new Promise((res) => {
        if (target === "image/png"){
          // PNG: si pngHint=off y ya es PNG y sin resize/fondo/cover/fit cambios, podríamos "pasar" original,
          // pero queremos consistencia de pipeline; si off igual re-encode solo cuando necesario.
          // Acá: si off y no hay resize y bg transparente y destino PNG y el original ya era PNG -> devolvemos original.
          const needsTransform =
            resizeModeSel.value !== "none" ||
            (bgModeSel.value !== "transparent") ||
            (entry.file.type !== "image/png") ||
            (pngHint === "on");

          if (!needsTransform && entry.file.type === "image/png"){
            res(entry.file);
            return;
          }
          canvas.toBlob((b) => res(b), "image/png");
        } else {
          canvas.toBlob((b) => res(b), "image/jpeg", q);
        }
      });

      return { blob, outName };
    }

    async function convertAll(){
      if (files.length === 0) return;

      const target = targetSel.value;
      const bg = parseBg();

      // warning útil
      if (target === "image/jpeg"){
        const anyAlpha = files.some(x => x.hasAlpha);
        if (anyAlpha){
          setLog(`Convirtiendo a JPG: detecté transparencia en algunos PNG → se rellena con fondo.\nIniciando descargas…`);
        } else {
          setLog(`Convirtiendo a JPG… Iniciando descargas…`);
        }
      } else {
        setLog(`Convirtiendo a PNG… Iniciando descargas…`);
        if (bg === null){
          // ok
        }
      }

      convertBtn.disabled = true;
      pickBtn.disabled = true;
      clearBtn.disabled = true;

      let ok = 0;
      for (let i = 0; i < files.length; i++){
        const entry = files[i];
        try{
          const { blob, outName } = await convertOne(entry, i+1, files.length);
          if (!blob) throw new Error("Blob null");
          downloadBlob(blob, outName);
          ok++;
          setLog(`(${ok}/${files.length}) ✅ ${entry.file.name} → ${outName}`);
          // mini pausa para que el navegador procese descargas
          await new Promise(r => setTimeout(r, 120));
        }catch(e){
          setLog(`(${i+1}/${files.length}) ❌ Falló: ${entry.file.name}`);
        }
      }

      setLog(`Listo. Convertidos: ${ok}/${files.length}.`);
      convertBtn.disabled = false;
      pickBtn.disabled = false;
      clearBtn.disabled = false;
    }

    // Eventos UI
    pickBtn.addEventListener("click", () => fileInput.click());
    fileInput.addEventListener("change", (e) => addFiles(e.target.files));
    clearBtn.addEventListener("click", clearAll);
    convertBtn.addEventListener("click", convertAll);

    targetSel.addEventListener("change", updateUI);
    bgModeSel.addEventListener("change", updateUI);
    resizeModeSel.addEventListener("change", updateUI);

    // Drag & drop
    function stop(e){ e.preventDefault(); e.stopPropagation(); }

    ["dragenter","dragover"].forEach(ev => {
      drop.addEventListener(ev, (e) => { stop(e); drop.classList.add("dragover"); });
    });
    ["dragleave","drop"].forEach(ev => {
      drop.addEventListener(ev, (e) => { stop(e); drop.classList.remove("dragover"); });
    });
    drop.addEventListener("drop", async (e) => {
      const dt = e.dataTransfer;
      if (dt?.files?.length) addFiles(dt.files);
    });
    drop.addEventListener("click", () => fileInput.click());
    drop.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " "){
        e.preventDefault();
        fileInput.click();
      }
    });

    // Inicial
    updateUI();
    renderList();
  </script>
</body>
</html>
